<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Simulador - Arena do Insta</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
@import url('https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;700&display=swap');

body {
    font-family: 'Chakra Petch', sans-serif;
    background-color: #1a1a2e;
    color: #fff;
    margin: 0;
    display: flex;
    justify-content: center;
    align-items: flex-start;
    padding: 20px;
    min-height: 100vh;
    position: relative;
}

#app-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
}

canvas {
    background-color:#000000;
    border-radius:10px;
    box-shadow:inset 0 0 10px rgba(0,0,0,0.7);
    display:block;
}

.header {
    background-color: #2c2c54;
    padding: 20px;
    margin-bottom: 10px;
    border-radius: 8px;
    text-align: center;
    width: 750px;
}

.status-box {
    background-color: #2c2c54;
    border-radius: 8px;
    padding: 15px;
    box-shadow:0 2px 10px rgba(0,0,0,0.5);
    width: 750px;
    display:flex;
    flex-direction: column;
    align-items:center;
    gap: 10px;
}

.action-button {
    transition:all 0.2s ease-in-out;
    padding:10px 20px;
    border-radius:8px;
    font-weight:bold;
    cursor:pointer;
    text-align:center;
    width:90%;
    color: white;
}
.action-button:hover {
    opacity:0.9;
}

.upload-label { background-color:#22c55e; }
.export-button { background-color: #0284c7; }

#side-panel {
    position: absolute;
    right: 20px;
    top: 50%;
    transform: translateY(-50%);
    width: 220px;
    background-color: #2c2c54;
    border-radius: 8px;
    padding: 15px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.5);
    display: flex;
    flex-direction: column;
    gap: 10px;
}
#side-panel button, #side-panel a {
    width: 100%;
    padding: 10px;
    border-radius: 6px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.2s ease;
    text-align: center;
    text-decoration: none;
    color: white;
}

#resetButton { background-color: #d97706; }
#resetButton:hover { opacity: 0.9; }

#linkToRanking { background-color: #8b5cf6; }
#linkToRanking:hover { opacity: 0.9; }

.search-input {
    width: 100%;
    padding: 8px;
    border-radius: 6px;
    background-color: #1a1a2e;
    border: 1px solid #4a4e69;
    color: #fff;
}
.search-button {
    width: 100%;
    background-color: #8b5cf6;
    color: white;
    padding: 8px;
    border-radius: 6px;
    font-weight: bold;
}

</style>
</head>
<body>

<div id="app-container">
    <div class="header">
        <h1 class="text-4xl font-bold mb-2">ARENA DO INSTA</h1>
        <p class="text-gray-300 mt-1 text-xl">Simulador de Rodadas</p>
    </div>

    <canvas id="collisionCanvas" width="750" height="600"></canvas>

    <div class="status-box">
        <div id="statusMessage" class="text-lg font-semibold text-yellow-300 text-center">Aguardando imagens...</div>
        
        <input type="file" id="imageUpload" multiple accept="image/*" style="display:none;">
        <label for="imageUpload" class="action-button upload-label">üñºÔ∏è Carregar Fotos</label>
        
        <button id="exportRankingButton" class="action-button export-button" style="display:none;">üèÜ Salvar Ranking Final (.json)</button>
        
        <div id="search-container" style="display: none; width: 90%; margin-top: 10px; text-align: center;">
            <p class="text-base text-gray-400 mb-2">Confira sua posi√ß√£o:</p>
            <input type="text" id="searchInput" placeholder="Digite seu @username para buscar..." class="search-input">
            <button id="searchButton" class="search-button mt-2">üîç Buscar Posi√ß√£o</button>
            <p id="searchResult" class="mt-3 text-lg h-8"></p>
        </div>
    </div>
</div>

<div id="side-panel">
    <a id="linkToRanking" href="index.html">üìà Ver Ranking P√∫blico</a>
    <button id="resetButton" style="display:none;">üîÑ Reiniciar Simula√ß√£o</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/@vercel/speed-insights/dist/script.js" async></script>

<script>
// --- Constantes da Simula√ß√£o ---
const INITIAL_RADIUS = 25; 
const MAX_RADIUS = 40;
const MAX_SPEED = 2.0; 
const MIN_SPEED = 0.5;
const ELIMINATION_THRESHOLD = 25; // Mais batidas para eliminar
const NORMAL_GROWTH_RATE = 0.05;
const SLOW_GROWTH_RATE = 0.01;
const FINAL_GROWTH_BOOST = 0.02;

// --- Vari√°veis Globais ---
let canvas, ctx, profiles=[], animationFrameId, isGameOver=false, lastTime=0, followerImageUrls=[];
let finalRankingData = [];
let rodadaTitle = "CLASSIFICA√á√ÉO DA RODADA"; // <-- ALTERA√á√ÉO 1: Vari√°vel global adicionada
let eliminationCounter = 1;
const imageCache = new Map();
let grid;
let eliminatedLog = [];

class SpatialGrid {
    constructor(width, height, cellSize) { this.cellSize = cellSize; this.cols = Math.ceil(width / cellSize); this.rows = Math.ceil(height / cellSize); this.grid = new Map(); }
    clear() { this.grid.clear(); }
    insert(profile) { const col = Math.floor(profile.x / this.cellSize); const row = Math.floor(profile.y / this.cellSize); const key = `${col},${row}`; if (!this.grid.has(key)) { this.grid.set(key, []); } this.grid.get(key).push(profile); }
    getNearby(profile) { const nearby = []; const col = Math.floor(profile.x / this.cellSize); const row = Math.floor(profile.y / this.cellSize); for (let r = -1; r <= 1; r++) { for (let c = -1; c <= 1; c++) { const key = `${col + c},${row + r}`; if (this.grid.has(key)) { nearby.push(...this.grid.get(key)); } } } return nearby; }
}

class Profile {
    constructor(id, username, x, y, vx, vy, imageUrl){
        this.id=id; this.username=username; this.x=x; this.y=y; this.vx=vx; this.vy=vy;
        this.radius=INITIAL_RADIUS; this.collisionCount=0; this.alive=true;
        this.eliminationOrder = null;
        this.eliminatedBy = null;
        this.eliminatedList = [];
        this.image=imageCache.get(imageUrl);
        if(!this.image){ this.image=new Image(); this.image.src=imageUrl; imageCache.set(imageUrl,this.image); }
    }
    update(dt,totalAlive){
        if(!this.alive) return;
        let speedFactor = Math.max(MIN_SPEED, Math.min(MAX_SPEED, Math.pow(followerImageUrls.length / totalAlive, 0.4)));
        if(totalAlive <= 10) speedFactor *= 1.2;
        if(totalAlive <= 5) speedFactor *= 1.5;
        
        if(Math.abs(this.vx)<0.2) this.vx += this.vx>0?0.2:-0.2;
        if(Math.abs(this.vy)<0.2) this.vy += this.vy>0?0.2:-0.2;
        this.x += this.vx * dt * 60 * speedFactor;
        this.y += this.vy * dt * 60 * speedFactor;
        
        let currentGrowthRate;
        if (totalAlive <= 20) {
            currentGrowthRate = FINAL_GROWTH_BOOST;
        } else if (totalAlive <= 200) {
            currentGrowthRate = SLOW_GROWTH_RATE;
        } else {
            currentGrowthRate = NORMAL_GROWTH_RATE;
        }
        
        const dynamicFinalRadius = INITIAL_RADIUS + (MAX_RADIUS - INITIAL_RADIUS) * (1 - totalAlive / followerImageUrls.length);
        if(this.radius < dynamicFinalRadius){ this.radius += currentGrowthRate * dt * 60; if(this.radius > dynamicFinalRadius) this.radius = dynamicFinalRadius; }
        
        if(this.x-this.radius<0){ this.x=this.radius; this.vx*=-1;}
        else if(this.x+this.radius>canvas.width){ this.x=canvas.width-this.radius; this.vx*=-1;}
        if(this.y-this.radius<0){ this.y=this.radius; this.vy*=-1;}
        else if(this.y+this.radius>canvas.height){ this.y=canvas.height-this.radius; this.vy*=-1;}
    }
    draw(ctx, aliveCount){
        if(!this.alive) return;

        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = '#ffffff';
        ctx.fill();
        
        if (this.image && this.image.complete && this.image.width > 0) {
            const imgWidth = this.image.width;
            const imgHeight = this.image.height;
            const diagonalHalf = Math.sqrt(Math.pow(imgWidth / 2, 2) + Math.pow(imgHeight / 2, 2));
            const scale = this.radius / diagonalHalf;
            const drawWidth = imgWidth * scale;
            const drawHeight = imgHeight * scale;
            const centeredX = this.x - drawWidth / 2;
            const centeredY = this.y - drawHeight / 2;
            ctx.drawImage(this.image, centeredX, centeredY, drawWidth, drawHeight);
        }

        if(aliveCount <= 200){
            const barW = this.radius*2; const barH = 3; const barX = this.x - barW/2; const barY = this.y - this.radius - 5;
            const healthRatio = (ELIMINATION_THRESHOLD - this.collisionCount)/ELIMINATION_THRESHOLD;
            ctx.fillStyle = "rgba(51,51,51,0.6)"; ctx.fillRect(barX, barY, barW, barH);
            let barColor = healthRatio > 0.6 ? "limegreen" : healthRatio > 0.3 ? "gold" : "red";
            ctx.fillStyle = barColor; ctx.fillRect(barX, barY, barW * healthRatio, barH);
            ctx.strokeStyle = "rgba(255,255,255,0.3)"; ctx.strokeRect(barX, barY, barW, barH);
        }
    }
}

function initProfiles(){
    // ALTERA√á√ÉO 2: Pede um t√≠tulo ao usu√°rio no in√≠cio
    const userTitle = prompt("Digite o t√≠tulo para esta rodada:", "Classifica√ß√£o da Rodada");
    if (userTitle) {
        rodadaTitle = userTitle.toUpperCase();
    }
    
    canvas=document.getElementById('collisionCanvas'); ctx=canvas.getContext('2d');
    grid = new SpatialGrid(canvas.width, canvas.height, MAX_RADIUS * 2);
    profiles=[]; isGameOver=false; lastTime=performance.now();
    eliminationCounter = 1;
    eliminatedLog = [];
    finalRankingData = []; 
    document.getElementById('search-container').style.display = 'none'; 
    document.getElementById('searchInput').value = ''; 
    document.getElementById('searchResult').textContent = '';
    document.getElementById('statusMessage').textContent = `${followerImageUrls.length} perfis em batalha!`;
    document.getElementById('exportRankingButton').style.display = 'none';
    document.getElementById('resetButton').style.display = 'block';

    for(let i=0;i<followerImageUrls.length;i++){
        const imageObj=followerImageUrls[i];
        let placed=false; let attempts=0;
        let x, y;
        while(!placed && attempts < 2000){
            x = Math.random()*(canvas.width-INITIAL_RADIUS*2)+INITIAL_RADIUS;
            y = Math.random()*(canvas.height-INITIAL_RADIUS*2)+INITIAL_RADIUS;
            const hasOverlap = profiles.some(p => Math.hypot(p.x - x, p.y - y) < (INITIAL_RADIUS * 2 + 4));
            if(!hasOverlap){ placed = true; }
            attempts++;
        }
        if(!placed){ x = Math.random()*(canvas.width-INITIAL_RADIUS*2)+INITIAL_RADIUS; y = Math.random()*(canvas.height-INITIAL_RADIUS*2)+INITIAL_RADIUS; }

        const vx = (Math.random() - 0.5) * MAX_SPEED * 1.2; 
        const vy = (Math.random() - 0.5) * MAX_SPEED * 1.2; 

        profiles.push(new Profile(i, imageObj.name, x, y, vx, vy, imageObj.url));
    }
}

function detectCollisions(alive) {
    if(alive.length < 2) return;
    if(alive.length === 2){
        const [p1, p2] = alive;
        if(Math.hypot(p2.x - p1.x, p2.y - p1.y) < p1.radius + p2.radius){
            let loser, winner;
            if (p1.collisionCount < p2.collisionCount) {
                loser = p2; winner = p1;
            } else if (p2.collisionCount < p1.collisionCount) {
                loser = p1; winner = p2;
            } else {
                loser = Math.random() < 0.5 ? p1 : p2;
                winner = loser === p1 ? p2 : p1;
            }
            if (loser.alive) {
                loser.alive = false; 
                loser.eliminationOrder = eliminationCounter++;
                loser.eliminatedBy = winner.username;
                winner.eliminatedList.push(loser.username);
                eliminatedLog.push(loser.username);
            }
        }
        return;
    }
    grid.clear();
    alive.forEach(p => grid.insert(p));
    for (const p1 of alive) {
        for (const p2 of grid.getNearby(p1)) {
            if (p1.id >= p2.id) continue;
            const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            if (dist < p1.radius + p2.radius) {
                const overlap = (p1.radius + p2.radius - dist)/2;
                const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                const sx=Math.cos(angle)*overlap, sy=Math.sin(angle)*overlap;
                p1.x-=sx; p1.y-=sy; p2.x+=sx; p2.y+=sy;
                p1.vx*=-1; p1.vy*=-1; p2.vx*=-1; p2.vy*=-1;
                p1.collisionCount++; p2.collisionCount++;
                if(p1.collisionCount>=ELIMINATION_THRESHOLD && p1.alive){ 
                    p1.alive=false; 
                    p1.eliminationOrder = eliminationCounter++;
                    p1.eliminatedBy = p2.username;
                    p2.eliminatedList.push(p1.username);
                    eliminatedLog.push(p1.username);
                }
                if(p2.collisionCount>=ELIMINATION_THRESHOLD && p2.alive){ 
                    p2.alive=false; 
                    p2.eliminationOrder = eliminationCounter++; 
                    p2.eliminatedBy = p1.username;
                    p1.eliminatedList.push(p2.username);
                    eliminatedLog.push(p2.username);
                }
            }
        }
    }
}

function drawEliminatedLog() {
    ctx.fillStyle = "#ccc";
    ctx.font = "bold 11px Chakra Petch";
    ctx.textAlign = "left";
    ctx.fillText("Eliminados:", 10, 25);
    
    ctx.font = "11px Chakra Petch";
    
    eliminatedLog.forEach((name, index) => {
        const yPos = 45 + index * 14;
        
        if (yPos < canvas.height - 10) { 
             ctx.fillText(name, 10, yPos);
        }
    });
}

function drawFinalRankingList() {
    ctx.fillStyle = "#2c2c54";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = "#fff";
    ctx.textAlign = "center";
    
    ctx.font = `bold 24px Chakra Petch`;
    // ALTERA√á√ÉO 3: Usa a vari√°vel para definir o t√≠tulo
    ctx.fillText(rodadaTitle, canvas.width / 2, 30);
    
    ctx.font = `bold 14px Chakra Petch`;
    const totalParticipants = finalRankingData.length;
    const maxToShow = Math.min(totalParticipants, 20); 

    ctx.textAlign = "left";
    ctx.fillStyle = "#8b5cf6";
    ctx.fillText("Pos.", 20, 70);
    ctx.fillText("Time", 60, 70);
    ctx.textAlign = "right";
    ctx.fillText("Pontos", canvas.width / 2 - 20, 70);

    if (totalParticipants > maxToShow) {
        ctx.textAlign = "left";
        ctx.fillStyle = "#8b5cf6";
        ctx.fillText("Pos.", 20 + canvas.width / 2, 70);
        ctx.fillText("Time", 60 + canvas.width / 2, 70);
        ctx.textAlign = "right";
        ctx.fillText("Pontos", canvas.width - 20, 70);
    }
    
    ctx.font = `14px Chakra Petch`;
    let startY = 100;

    for (let i = 0; i < totalParticipants; i++) {
        const p = finalRankingData[i];
        const points = totalParticipants - p.rank + 1;
        
        let col = Math.floor(i / maxToShow);
        let row = i % maxToShow;
        
        let xPos = 20 + (col * (canvas.width / 2));
        let xImage = 60 + (col * (canvas.width / 2));
        let xTime = xImage + 22;
        let xPoints = (canvas.width / 2 - 20) + (col * (canvas.width / 2));
        let yPos = startY + row * 22;

        let textColor = "#fff";

        ctx.textAlign = "left";
        ctx.textBaseline = "middle"; 
        ctx.fillStyle = textColor;
        ctx.fillText(`${p.rank}¬∫`, xPos, yPos);
        
        const imageSize = 18;
        const imageToDraw = imageCache.get(p.imageUrl);
        
        if (imageToDraw && imageToDraw.complete) {
            const hRatio = imageSize / imageToDraw.width;
            const vRatio = imageSize / imageToDraw.height;
            const ratio = Math.min(hRatio, vRatio);
            const centeredX = xImage + (imageSize - imageToDraw.width * ratio) / 2;
            const centeredY = yPos - (imageToDraw.height * ratio) / 2;
            ctx.drawImage(imageToDraw, centeredX, centeredY, imageToDraw.width * ratio, imageToDraw.height * ratio);
        }

        ctx.fillText(p.username, xTime, yPos);

        ctx.textAlign = "right";
        ctx.fillText(points, xPoints, yPos);

        if (i < totalParticipants - 1 && (row + 1) % maxToShow !== 0) {
            ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
            ctx.beginPath();
            ctx.moveTo(xPos, yPos + 11);
            ctx.lineTo(xPoints + 20, yPos + 11);
            ctx.stroke();
        }
    }
    ctx.textBaseline = "alphabetic";
}

function animate(time){
    if(!ctx) return;
    const dt=(time-lastTime)/1000 || 0; lastTime=time;
    const alive = profiles.filter(p=>p.alive);
    
    detectCollisions(alive);
    alive.forEach(p=>p.update(dt, alive.length));
    
    if(alive.length<=1 && followerImageUrls.length > 1) isGameOver=true;
    
    ctx.clearRect(0,0,canvas.width,canvas.height);

    if(isGameOver){
        if (finalRankingData.length === 0) {
            generateFinalRanking();
        }
        drawFinalRankingList();
        
        document.getElementById('exportRankingButton').style.display = 'block';
        document.getElementById('search-container').style.display = 'block';
        
        document.getElementById('statusMessage').textContent = 'FIM DE JOGO! Salve o ranking ou busque sua posi√ß√£o.';
        document.getElementById('statusMessage').style.color = '#000000';
    } else {
        alive.forEach(p=>p.draw(ctx, alive.length));
        animationFrameId=requestAnimationFrame(animate);
        
        drawEliminatedLog();
    }
}

function generateFinalRanking() {
    finalRankingData = profiles
        .sort((a, b) => {
            if (a.alive && !b.alive) return -1;
            if (!a.alive && b.alive) return 1;
            if (!a.alive && !b.alive) return b.eliminationOrder - a.eliminationOrder;
            return 0;
        })
        .map((p, index) => {
            const rank = index + 1;
            let rankStatus = p.alive ? 'üèÜ 1¬∫ Lugar' : rank === 2 ? 'ü•à 2¬∫ Lugar' : rank === 3 ? 'ü•â 3¬∫ Lugar' : `Eliminado`;
            return {
                username: p.username,
                rank: rank,
                status: rankStatus,
                eliminatedCount: p.eliminatedList.length,
                eliminatedList: p.eliminatedList,
                eliminatedBy: p.eliminatedBy || 'Sobrevivente',
                imageUrl: followerImageUrls.find(img => img.name === p.username)?.url || p.image.src
            };
        });
}

function exportRanking() {
    if (finalRankingData.length === 0) {
        alert("A simula√ß√£o precisa terminar para exportar o ranking.");
        return;
    }
    const blob = new Blob([JSON.stringify(finalRankingData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'ranking_final.json';
    a.click();
    URL.revokeObjectURL(url);
    alert("Arquivo 'ranking_final.json' baixado com sucesso! Lembre-se de substituir o arquivo no seu reposit√≥rio Git e dar PUSH para que o Ranking P√∫blico seja atualizado.");
}

document.addEventListener('DOMContentLoaded', () => {
    canvas = document.getElementById('collisionCanvas');
    ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    document.getElementById('imageUpload').addEventListener('change', (e) => {
        const files=Array.from(e.target.files);
        if(files.length===0) return;
        const readers=files.map(f=>new Promise((res,rej)=>{
            const r=new FileReader();
            r.onload = () => res({ url: r.result, name: f.name.replace(/\.[^/.]+$/, '') });
            r.onerror=rej;
            r.readAsDataURL(f);
        }));
        Promise.all(readers).then(results=>{
            followerImageUrls=results;
            initProfiles();
            if(animationFrameId) cancelAnimationFrame(animationFrameId);
            animate(performance.now());
        });
    });

    document.getElementById('resetButton').addEventListener('click', () => {
        if (followerImageUrls.length === 0) {
             alert("Carregue as imagens primeiro para reiniciar.");
             return;
        }
        cancelAnimationFrame(animationFrameId);
        initProfiles();
        animate(performance.now());
    });

    document.getElementById('exportRankingButton').addEventListener('click', exportRanking);
    
    document.getElementById('searchButton').addEventListener('click', () => {
        const searchInput = document.getElementById('searchInput');
        const resultElement = document.getElementById('searchResult');
        const query = searchInput.value.trim().toLowerCase().replace('@', '');

        if (finalRankingData.length === 0) {
            resultElement.textContent = 'Aguarde o fim do jogo para buscar.';
            resultElement.style.color = '#facc15';
            return;
        }

        if (!query) {
            resultElement.textContent = 'Digite um nome para buscar.';
            resultElement.style.color = '#facc1e';
            return;
        }

        const foundProfile = finalRankingData.find(p => p.username.toLowerCase() === query);

        if (foundProfile) {
            resultElement.innerHTML = `üéâ <strong>${foundProfile.rank}¬∫</strong> Lugar - ${foundProfile.status}`;
            resultElement.style.color = '#34d399';
        } else {
            resultElement.textContent = 'üòï Usu√°rio n√£o encontrado.';
            resultElement.style.color = '#f87171';
        }
    });
});
</script>
</body>
</html>